#version 430 core

#pragma optimize(on)

layout(local_size_x = {LocalSizeX}) in;

struct ShaderConfig {
    int agentsCount;
    int width;
    int height;
    float dt;
    float t;
};

struct Agent
{
    vec2 position;
    float angle;
    uint type;
    float energy;
    float age;
    int state;
    int nnOffset;
};

layout(std430, binding = 0) buffer ConfigBuffer {
    ShaderConfig config;
};

layout(std430, binding = 1) buffer AgentsBuffer {
    Agent agents[];
};

layout(rgba32f, binding = 2) uniform image2D inGreen;
layout(rgba32f, binding = 3) uniform image2D inBlue;
layout(rgba32f, binding = 4) uniform image2D inRed;

layout(std430, binding = 5) buffer NetworkBuffer {
    float network[];
};


void torus(inout vec2 pos)
{
    if (pos.x > config.width)
        pos.x -= config.width;
    else if (pos.x < 0)
        pos.x += config.width;

    if (pos.y > config.height)
        pos.y -= config.height;
    else if (pos.y < 0)
        pos.y += config.height;
}

void itorus(inout ivec2 pos)
{
    if (pos.x > config.width)
        pos.x -= config.width;
    else if (pos.x < 0)
        pos.x += config.width;

    if (pos.y > config.height)
        pos.y -= config.height;
    else if (pos.y < 0)
        pos.y += config.height;
}

uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float scaleToRange01(uint state)
{
    return state / 4294967295.0;
}

float get_random_float_01(Agent agent, uint seed)
{
     uint random = hash(uint(agent.position.y * config.width + agent.position.x) + hash(gl_GlobalInvocationID.x + int(config.t) * seed));
     float random01 = scaleToRange01(random);
     return random01;
}

float sense_green(Agent agent, float sensorAngle, float sensorDist, int sensorSize)
{
    float sensingAngle = agent.angle + sensorAngle;
    vec2 sensingDir = vec2(cos(sensingAngle),sin(sensingAngle));
    vec2 sensingCenter = agent.position + sensingDir * sensorDist;
    ivec2 center = ivec2(int(sensingCenter.x),int(sensingCenter.y));
    float sum = 0;
    for(int offsetX=-sensorSize; offsetX <= sensorSize; offsetX++)
        for(int offsetY=-sensorSize; offsetY <= sensorSize; offsetY++)
        {
            ivec2 sensePixel = center + ivec2(offsetX, offsetY);
            itorus(sensePixel);
            sum += imageLoad(inGreen, sensePixel).r;
        }

    uint r = 2*sensorSize+1;
    return sum / (r*r);
}

float sense_blue(Agent agent, float sensorAngle, float sensorDist, int sensorSize)
{
    float sensingAngle = agent.angle + sensorAngle;
    vec2 sensingDir = vec2(cos(sensingAngle),sin(sensingAngle));
    vec2 sensingCenter = agent.position + sensingDir * sensorDist;
    ivec2 center = ivec2(int(sensingCenter.x),int(sensingCenter.y));
    float sum = 0;
    for(int offsetX=-sensorSize; offsetX <= sensorSize; offsetX++)
        for(int offsetY=-sensorSize; offsetY <= sensorSize; offsetY++)
        {
            ivec2 sensePixel = center + ivec2(offsetX, offsetY);
            itorus(sensePixel);
            sum += imageLoad(inBlue, sensePixel).r;
        }

    uint r = 2*sensorSize+1;
    return sum / (r*r);
}

float sense_red(Agent agent, float sensorAngle, float sensorDist, int sensorSize)
{
    float sensingAngle = agent.angle + sensorAngle;
    vec2 sensingDir = vec2(cos(sensingAngle),sin(sensingAngle));
    vec2 sensingCenter = agent.position + sensingDir * sensorDist;
    ivec2 center = ivec2(int(sensingCenter.x),int(sensingCenter.y));
    float sum = 0;
    for(int offsetX=-sensorSize; offsetX <= sensorSize; offsetX++)
        for(int offsetY=-sensorSize; offsetY <= sensorSize; offsetY++)
        {
            ivec2 sensePixel = center + ivec2(offsetX, offsetY);
            itorus(sensePixel);
            sum += imageLoad(inRed, sensePixel).r;
        }

    uint r = 2*sensorSize+1;
    return sum / (r*r);
}

void update_one(uint idx)
{
    Agent agent = agents[idx];

    agent.age += config.dt;
    if (agent.type == 0 && agent.state == 1 && agent.age > 0)
        agent.state = 0;
       
    agents[idx] = agent;
    if (agent.state == 1)
        return;

    if (agent.type > 0)
    {
        float random01 = get_random_float_01(agent, 100037);
        float velocity = 0.5;
        agent.angle += (0.5-random01) * 0.1;
        agent.position += vec2(velocity*cos(agent.angle),velocity*sin(agent.angle));
    }
    
    torus(agent.position);
    agents[idx] = agent;

}

void main()
{
    uint idx = gl_GlobalInvocationID.x;

    if (idx >=0 && idx < config.agentsCount) 
    {
        update_one(idx);
    }
}